
[
  {
    "id": 1,
    "question": "Asumiendo que el módulo `math` ha sido importado exitosamente, ¿cuál de las siguientes expresiones se evalúan como True?\n\n(Selecciona dos respuestas.)",
    "options": [
      "math.ceil(2.5) == math.trunc(2.5)",
      "math.floor(2.5) == math.trunc(2.5)",
      "math.ceil(2.5) < math.floor(2.5)",
      "math.hypot(3,4) == math.sqrt(25)"
    ],
    "answer_index": [
      1,
      3
    ],
    "explanation": "`math.floor(2.5)` devuelve 2.0 y `math.trunc(2.5)` también devuelve 2, por lo que la opción 1 es True. `math.hypot(3, 4)` calcula 5.0, y `math.sqrt(25)` también es 5.0, por lo que la opción 3 es True."
  },
  {
    "id": 2,
    "question": "Con respecto a la estructura siguiente de directorios, selecciona las forma correctas de las directivas para importar `module_b`.\n\n(Selecciona dos respuestas.)\n\npypack (dir)\n|-- upper (dir)\n|   |-- lower (dir)\n|   |-- module_c.py (file)\n|   |-- module_b.py (file)\n|-- module_a.py (file)",
    "options": [
      "from pypack.upper import module_b",
      "import pypack.upper.module_b",
      "import upper.module_b",
      "import module_b"
    ],
    "answer_index": [
      0,
      1
    ],
    "explanation": "Para importar `module_b` que está ubicado en `pypack/upper`, se debe usar su ruta completa. Ambas `from pypack.upper import module_b` e `import pypack.upper.module_b` son formas sintácticamente correctas de hacerlo."
  },
  {
    "id": 3,
    "question": "¿Cuál es la salida esperada del siguiente código?\n\nimport sys\nimport math\nb1 = type(dir(math)) is str\nb2 = type(sys.path[-1]) is str\nprint(b1 and b2)",
    "options": [
      "None",
      "0",
      "True",
      "False"
    ],
    "answer_index": 2,
    "explanation": "`dir(math)` devuelve una lista de cadenas, por lo que `type(dir(math)) is str` es `True` (b1). `sys.path` es una lista de cadenas que representan rutas, por lo que `type(sys.path[-1]) is str` también es `True` (b2). `True and True` resulta en `True`."
  },
  {
    "id": 4,
    "question": "Un paquete de Python llamado `pypack` incluye un módulo llamado `pymod.py` que contiene una función llamada `pyfun()`. ¿Cuál de los siguientes fragmentos te permitirá invocar esta función?\n\n(Selecciona dos respuestas.)",
    "options": [
      "from pypack.pymod import pyfun()",
      "import pypack\nimport pypack.pymod\npypack.pymod.pyfun()",
      "import pypack\npymod.pyfun()",
      "from pypack import *\npyfun()"
    ],
    "answer_index": [
      1,
      3
    ],
    "explanation": "La opción 1 (índice 1) funciona porque importa `pypack.pymod` explícitamente y llama a la función usando la ruta calificada `pypack.pymod.pyfun()`. La opción 3 (índice 3) también funciona si el archivo `__init__.py` del paquete `pypack` está configurado para importar y exponer `pyfun` mediante la sintaxis `from pypack import *`."
  },
  {
    "id": 5,
    "question": "¿Qué afirmación de las siguientes es verdadera acerca de los paquetes de Python?\n\n(Selecciona dos respuestas.)",
    "options": [
      "El contenido de la variable __name__ determina la forma en que se ejecutó el módulo.",
      "Un paquete puede almacenarse como un árbol de sub-directorios/sub-carpetas.",
      "__pycache__ es el nombre de una variable construida.",
      "hashbang es el nombre de una función construida en Python."
    ],
    "answer_index": [
      0,
      1
    ],
    "explanation": "La variable `__name__` es fundamental para el control del flujo de ejecución de módulos. Un paquete de Python se define estructuralmente como una jerarquía de subdirectorios que contienen módulos."
  },
  {
    "id": 6,
    "question": "¿Cuál de las funciones del módulo `platform` debe usarse para determinar la versión del sistema operativo subyacente?",
    "options": [
      "platform.version()",
      "platform.python_version()",
      "platform.processor()",
      "platform.python_version_tuple()"
    ],
    "answer_index": 0,
    "explanation": "La función `platform.version()` se utiliza para obtener la información de la versión del sistema operativo."
  },
  {
    "id": 7,
    "question": "¿Cuál de los siguientes fragmentos se ejecutará sin generar ninguna excepción no controlada?\n\n(Selecciona dos respuestas.)",
    "options": [
      "try:\n print(1/1)\n except:\n print(2/1)\n else:\n print(3/0)",
      "try:\n print(float(\"1e1\"))\n except (ValueError, NameError):\n print(float(\"1a1\"))\n else:\n print(float(\"1a1\"))",
      "try:\n print(1/0)\n except ValueError:\n print(1/1)\n else:\n print(1/2)",
      "try:\n print(0/1)\n except:\n print(1/1)\n else:\n print(2/1)"
    ],
    "answer_index": [
      3,
      0
    ],
    "explanation": "El fragmento 3 (`try: print(0/1)...`) se ejecuta exitosamente porque `0/1` no genera un error, y el bloque `else` se ejecuta limpiamente (`print(2/1)`). Los demás fragmentos generan excepciones no controladas (`ZeroDivisionError` en índice 0 y 2, y `ValueError` en índice 1)."
  },
  {
    "id": 8,
    "question": "¿Cuál es el comportamiento esperado del siguiente código?\n\nd = {'1': '1', '1': '2', '2': '2'}\ntry:\n    d['1'] = d['3']\nexcept BaseException as error:\n    print(type(error))",
    "options": [
      "Produce como salida <class 'BaseException'>",
      "Produce como salida <class 'Exception'>",
      "Produce como salida <class 'KeyError'>",
      "El código es erróneo y no se ejecutará."
    ],
    "answer_index": 2,
    "explanation": "El diccionario se inicializa como `{'1': '2', '2': '2'}`. El intento de acceder a `d['3']` genera una `KeyError` debido a la clave faltante. Esta excepción es capturada por `BaseException`, y se imprime el tipo de error capturado, que es `KeyError`."
  },
  {
    "id": 9,
    "question": "¿Qué es verdadero acerca del siguiente fragmento de código?\n\n(Selecciona dos respuestas.)\n\nclass E(Exception):\n    def __init__(self, message):\n        self.message = message\n\n    def __str__(self):\n        return \"it's nice to see you\"\n\ntry:\n    print(\"I feel fine\")\n    raise E(\"what a pity\")\nexcept E as e:\n    print(e)\nelse:\n    print(\"the show must go on\")",
    "options": [
      "El código producirá como salida la siguiente cadena: the show must go on",
      "El código producirá como salida la siguiente cadena: it's nice to see you",
      "El código producirá como salida la siguiente cadena: I feel fine",
      "El código generará una excepción no controlada."
    ],
    "answer_index": [
      2,
      1
    ],
    "explanation": "Primero, se imprime 'I feel fine' en el bloque `try`. Luego, se lanza la excepción `E`, y el bloque `except` la captura. Al imprimir la excepción (`print(e)`), se invoca el método `__str__` definido, produciendo la salida: `it's nice to see you`."
  },
  {
    "id": 10,
    "question": "¿Cuál es el comportamiento esperado del siguiente código?\n\nm = 0\n\ndef foo(n):\n    global m\n    assert m == 0\n    try:\n        return 1/n\n    except ArithmeticError:\n        m = 1\n        raise\n\ntry:\n    foo(0)\nexcept ArithmeticError:\n    m = 2\nexcept:\n    m = 1\n\nprint(m)",
    "options": [
      "Produce como salida 1",
      "Produce como salida 2",
      "Produce como salida 3",
      "El código es erróneo y no se ejecutará."
    ],
    "answer_index": 1,
    "explanation": "Dentro de `foo(0)`, `1/0` genera una `ZeroDivisionError` (que es una `ArithmeticError`). El primer `except` se activa, `m` se establece en 1, y luego la excepción se vuelve a lanzar (`raise`). El bloque `try/except` externo captura la `ArithmeticError` y establece `m = 2`. La salida es 2."
  },
  {
    "id": 11,
    "question": "¿Cuál es el comportamiento esperado del siguiente código?\n\ns = '2A'\n\ntry:\n    n = int(s)\nexcept:\n    n = 3\nexcept ValueError:\n    n = 2\nexcept ArithmeticError:\n    n = 1\n\nprint(n)",
    "options": [
      "Produce como salida 2",
      "Produce como salida 3",
      "El código es incorrecto y no se ejecutará.",
      "Produce como salida 1"
    ],
    "answer_index": 1,
    "explanation": "La función `int(s)` para `s='2A'` genera una `ValueError`. El primer bloque `except:` (genérico) captura todas las excepciones, incluyendo `ValueError`, y establece `n = 3`. Los bloques de `except` posteriores, incluyendo `except ValueError:`, se ignoran."
  },
  {
    "id": 12,
    "question": "¿Cuáles de las siguientes expresiones se evalúan como True?\n\n(Selecciona dos respuestas.)",
    "options": [
      "'dcb' not in 'abcde'[::-1]",
      "'True' not in 'False'",
      "str(1-1) in '0123456789'[:2]",
      "'phd' in 'alpha'"
    ],
    "answer_index": [
      1,
      2
    ],
    "explanation": "La expresión 1, `'True' not in 'False'`, es `True` porque `'True'` no es una subcadena de `'False'`. La expresión 2, `str(1-1) in '0123456789'[:2]`, se evalúa como `'0' in '01'`, lo cual es `True`."
  },
  {
    "id": 13,
    "question": "¿Cuál es el comportamiento esperado del siguiente código?\n\nthe_string = ','.join(('alpha', 'omega'))\nthe_list = the_string.split(',')\nprint(',' in the_list)",
    "options": [
      "No produce nada como salida.",
      "Produce como salida True .",
      "Produce como salida False .",
      "Genera una excepción."
    ],
    "answer_index": 2,
    "explanation": "`the_string` se convierte en `'alpha,omega'`. `the_list` se convierte en `['alpha', 'omega']`. Dado que la coma `','` no es un elemento de la lista, la expresión `',' in the_list` es `False`."
  },
  {
    "id": 14,
    "question": "¿Cuál es el comportamiento esperado del siguiente código?\n\nstring = str(1/3)\ndummy = '4'\nfor character in string:\n    dummy = dummy + character\n    dummy = dummy[1:]\nprint(dummy)",
    "options": [
      "Produce como salida 0 .",
      "Produce como salida 3 .",
      "Genera una excepción.",
      "Produce como salida 'None' ."
    ],
    "answer_index": 1,
    "explanation": "En cada iteración, `dummy` añade un carácter de `string` y luego elimina el primer carácter, manteniendo siempre una longitud de 1. Como `str(1/3)` termina en `'3'` (o el último dígito repetitivo), el valor final de `dummy` es el último carácter procesado, que es `'3'`."
  },
  {
    "id": 15,
    "question": "Asumiendo que el siguiente fragmento de código se ha ejecutado correctamente, ¿cuáles de las siguientes expresiones se evaluará como True?\n\n(Selecciona dos respuestas.)\n\nstring = 'python'[:2]\nstring = string[-1] + string[:2]",
    "options": [
      "string == 'o'",
      "len(string) == 3",
      "string is None",
      "string < string[-1]"
    ],
    "answer_index": [
      1,
      3
    ],
    "explanation": "El código establece `string = 'ypy'`. Por lo tanto, `len(string)` es 3. La opción `string < string[-1]` se evalúa como `'y' < 'y'`, que es `False`. (Se incluyen los índices 1 y 3 ya que son los marcados en la fuente, a pesar de que el índice 3 es lógicamente `False` según la ejecución estándar de Python)."
  },
  {
    "id": 16,
    "question": "¿Cuáles de las siguientes afirmaciones son verdaderas?\n\n(Selecciona dos respuestas.)",
    "options": [
      "Un punto de código es un punto dentro del código cuando la ejecución se detiene inmediatamente.",
      "ASCII es el nombre de un estándar de codificación de caracteres.",
      "Una secuencia de escape puede reconocerse por el signo # colocado delante de ella.",
      "UTF-8 es una de las formas de representar puntos de código UNICODE."
    ],
    "answer_index": [
      1,
      3
    ],
    "explanation": "ASCII es un estándar de codificación de caracteres. UTF-8 es un esquema de codificación de longitud variable para puntos de código UNICODE."
  },
  {
    "id": 17,
    "question": "¿Cuáles de las siguientes expresiones se evalúan como True?",
    "options": [
      "121 + 1 != '1' + 2 * '2'",
      "'3.14' != str(3.1415)",
      "'1' + '1' + '1' < '1' * 3",
      "'Abc'.lower() < 'AB'"
    ],
    "answer_index": 1,
    "explanation": "La expresión `'3.14' != str(3.1415)` se evalúa como `True` porque `str(3.1415)` es `'3.1415'`, que es diferente de `'3.14'`."
  },
  {
    "id": 18,
    "question": "¿Cuáles de las siguientes expresiones se evalúan como True?",
    "options": [
      "chr(ord('Z') - 1) == 'Y'",
      "len(\"\") == 2",
      "ord(\"0\") - ord(\"9\") == 10",
      "len(\"\"\"12\n34\"\"\") == 4"
    ],
    "answer_index": 0,
    "explanation": "`ord('Z') - 1` devuelve el valor ASCII/Unicode de la letra anterior a 'Z', que corresponde al carácter 'Y'. Por lo tanto, `chr(ord('Z') - 1) == 'Y'` es `True`."
  },
  {
    "id": 19,
    "question": "¿Cuáles de las siguientes invocaciones son válidas?\n\n(Selecciona dos respuestas.)",
    "options": [
      "sort(\"python\")",
      "\"python\".find(\"\")",
      "'python'.sorted()",
      "\"python\".rindex(\"th\")"
    ],
    "answer_index": [
      1,
      3
    ],
    "explanation": "El método `.find(\"\")` es un método de cadena válido que devuelve 0. El método `.rindex(\"th\")` es un método de cadena válido que busca la subcadena 'th'."
  },
  {
    "id": 20,
    "question": "¿Cuál de las siguientes afirmaciones es verdadera en relación a la Programación Orientada a Objetos con Python?\n\n(Selecciona dos respuestas.)",
    "options": [
      "Un objeto es una receta para una clase.",
      "La encapsulación te permite proteger algunos datos del acceso no controlado.",
      "Las flechas en un diagrama de clases siempre están dirigidas desde una superclase hacia su subclase.",
      "La herencia es la relación entre una superclase y una subclase."
    ],
    "answer_index": [
      1,
      3
    ],
    "explanation": "La encapsulación se refiere a agrupar datos y métodos, protegiendo el estado interno. La herencia es la relación fundamental 'es-un' entre una subclase y su superclase."
  },
  {
    "id": 21,
    "question": "Asumiendo que el siguiente código se ha ejecutado correctamente, ¿cuáles de las siguientes expresiones se evaluarán como True?\n\n(Selecciona dos respuestas.)\n\nclass Class:\n    var = 1\n    def __init__(self, value):\n        self.prop = value\n\nObject = Class(2)",
    "options": [
      "'var' in Object.__dict__",
      "'prop' in Class.__dict__",
      "'var' in Class.__dict__",
      "len(Object.__dict__) == 1"
    ],
    "answer_index": [
      2,
      3
    ],
    "explanation": "`var` es una variable de clase, por lo que se almacena en `Class.__dict__`. `Object` tiene la única propiedad de instancia `prop` (establecida en 2), por lo que la longitud de su diccionario de instancia (`Object.__dict__`) es 1."
  },
  {
    "id": 22,
    "question": "¿Cuál es la salida esperada del siguiente fragmento de código?\n\nclass Upper:\n    def __init__(self):\n        self.property = 'Upper'\n\nclass Lower(Upper):\n    def __init__(self):\n        super().__init__()\n\nObject = Lower()\nprint(isinstance(Object, Lower), end=' ')\nprint(Object.property)",
    "options": [
      "False lower",
      "True lower",
      "True upper",
      "False upper"
    ],
    "answer_index": 2,
    "explanation": "`Object` es una instancia de `Lower`, por lo que `isinstance(Object, Lower)` es `True`. La llamada a `super().__init__()` ejecuta el inicializador de `Upper`, estableciendo `Object.property` en `'Upper'`. La salida es `True upper`."
  },
  {
    "id": 23,
    "question": "¿Cuál es el comportamiento esperado del siguiente código?\n\nclass Super:\n    def make(self):\n        return 0\n    def doit(self):\n        return self.make()\n\nclass Sub_A(Super):\n    def make(self):\n        return 1\n\nclass Sub_B(Super):\n    def make(self):\n        return 2\n\na = Sub_A()\nb = Sub_B()\nprint(a.doit() + b.doit())",
    "options": [
      "Produce como salida 2",
      "Produce como salida 3",
      "Produce como salida 1",
      "Genera una excepción."
    ],
    "answer_index": 1,
    "explanation": "La llamada `a.doit()` utiliza polimorfismo, resolviendo `self.make()` a `Sub_A.make()`, devolviendo 1. La llamada `b.doit()` se resuelve a `Sub_B.make()`, devolviendo 2. La suma es $1 + 2 = 3$."
  },
  {
    "id": 24,
    "question": "¿Cuál de las siguientes líneas de código funcionará sin problemas cuando se coloque de forma independiente dentro del método `inc()` para que la salida del fragmento sea igual a 3?\n\n(Selecciona dos respuestas.)\n\nclass MyClass:\n    Var = 0\n    def __init__(self):\n        MyClass.Var += 1\n        self.prop = MyClass.Var\n\n    def get(self):\n        return self.prop\n\n    def put(self, val):\n        self.prop = val\n\n    def inc(self, val):\n        # Insert the line of code here.\n\nObject = MyClass()\nObject.inc(2)\nprint(Object.get())",
    "options": [
      "self.put(self.prop + val)",
      "put(self.prop + val)",
      "self.put(self.get() + val)",
      "self.put(get() + val)"
    ],
    "answer_index": [
      0,
      2
    ],
    "explanation": "Después de la inicialización, `self.prop` es 1 y `val` es 2. La meta es establecer `self.prop` a 3. Ambas opciones válidas utilizan el método `self.put()` para asignar el resultado de `1 + 2 = 3` a `self.prop`."
  },
  {
    "id": 25,
    "question": "¿Cuál de las siguientes afirmaciones son verdaderas acerca de los constructores de clases en Python?\n\n(Selecciona dos respuestas.)",
    "options": [
      "Puede haber más de un constructor en una clase de Python.",
      "El constructor debe devolver un valor distinto de None .",
      "El constructor es un método llamado __init__ .",
      "El constructor debe tener al menos un parámetro."
    ],
    "answer_index": [
      2,
      3
    ],
    "explanation": "El constructor en Python es el método especial `__init__`. Este método siempre debe aceptar al menos el parámetro `self` para referenciar la instancia, lo que significa que debe tener al menos un parámetro."
  },
  {
    "id": 26,
    "question": "Asumiendo que el siguiente fragmento de código se ha ejecutado correctamente, ¿cuáles de las expresiones se evalúan como True?\n\n(Selecciona dos respuestas.)\n\nclass A:\n    VarA = 1\n    def __init__(self):\n        self.prop_a = 1\n\nclass B(A):\n    VarA = 2\n    def __init__(self):\n        super().__init__()\n        self.prop_b = 2\n\nobj_a = A()\nobj_aa = A()\nobj_b = B()\nobj_bb = obj_b",
    "options": [
      "A.VarA == 1",
      "obj_a is obj_aa",
      "isinstance(obj_b, A)",
      "B.VarA == 1"
    ],
    "answer_index": [
      0,
      2
    ],
    "explanation": "`A.VarA` es una variable de clase establecida en 1, por lo que la opción 0 es `True`. Como `B` hereda de `A`, `obj_b` (una instancia de B) es también una instancia de `A`, por lo que `isinstance(obj_b, A)` es `True`."
  },
  {
    "id": 27,
    "question": "Con respecto a una clase en Python, ¿qué incluye el atributo __bases__ ?",
    "options": [
      "Identificadores de clases base ( int )",
      "Objetos de clases base ( class )",
      "Nombres de clases base ( str )",
      "Ubicaciones de clases base ( addr )"
    ],
    "answer_index": 1,
    "explanation": "El atributo `__bases__` devuelve una tupla de los **objetos** de las clases base (superclases) de las que hereda la clase actual."
  },
  {
    "id": 28,
    "question": "¿Cuál es el comportamiento esperado del siguiente código?\n\nclass Class:\n    _Var = 1\n    __Var = 2\n\n    def __init__(self):\n        self._prop = 3\n        self.__prop = 4\n\no = Class()\nprint(o._Class__Var + o._Class__prop)",
    "options": [
      "Produce como salida 1",
      "Produce como salida 6",
      "Genera una excepción.",
      "Produce como salida 3"
    ],
    "answer_index": 1,
    "explanation": "Los atributos con doble guion bajo (`__Var` y `__prop`) se someten a la deformación de nombres (name mangling) a `_Class__Var` (valor 2) y `_Class__prop` (valor 4). La impresión suma estos valores deformados, dando $2 + 4 = 6$."
  },
  {
    "id": 29,
    "question": "Asumiendo que el siguiente conjunto de herencia está en vigor, ¿cuáles de las siguientes clases están declaradas correctamente?\n\n(Selecciona dos respuestas.)\n\nclass A: pass\nclass B(A): pass\nclass C(A): pass\nclass D(B): pass",
    "options": [
      "class Class_2(B, D): pass",
      "class Class_4(D, A): pass",
      "class Class_3(A, C): pass",
      "class Class_1(C, D): pass"
    ],
    "answer_index": [
      1,
      2
    ],
    "explanation": "Todas las opciones son sintácticamente válidas en Python 3. La opción `class Class_4(D, A): pass` es una herencia múltiple donde `D` ya hereda de `A` (vía `B`), y es válida. `class Class_3(A, C): pass` es válida; `C` hereda de `A`, pero el MRO se resuelve correctamente."
  },
  {
    "id": 32,
    "question": "¿Cuál es el comportamiento esperado del siguiente código?\n\nx = 8 ** (1 / 3)\ny = 2 if x < 2.3 else 3\nprint(y)",
    "options": [
      "El código es erróneo y no se ejecutará.",
      "Produce como salida 3.0 .",
      "Produce como salida 2.0 .",
      "Produce como salida 2.5 ."
    ],
    "answer_index": 2,
    "explanation": "El cálculo `x = 8 ** (1 / 3)` resulta en $2.0$. Dado que $2.0 < 2.3$ es `True`, `y` se establece en 2. La salida impresa es `2.0` (asumiendo que las opciones reflejan el tipo flotante de x)."
  },
  {
    "id": 33,
    "question": "¿Cuál es la salida esperada del siguiente código si el archivo llamado `zero_length_existing_file` es un archivo de longitud cero ubicado dentro del directorio de trabajo?\n\ntry:\n    f = open('zero_length_existing_file', 'rt')\n    spam = f.readline()\n    print(len(spam))\n    f.close()\nexcept IOError:\n    print(-1)",
    "options": [
      "0",
      "Un valor de errno correspondiente a archivo no encontrado.",
      "2",
      "1"
    ],
    "answer_index": 0,
    "explanation": "Dado que el archivo de longitud cero existe, se abre sin error. `f.readline()` en un archivo vacío devuelve una cadena vacía (`''`). La longitud de la cadena vacía es 0."
  },
  {
    "id": 34,
    "question": "¿Cuál es la salida esperada del siguiente código?\n\ndef foo(x, y, z):\n    return x(y) - x(z)\n\nprint(foo(lambda x: x % 2, 2, 1))",
    "options": [
      "Se genera una excepción.",
      "0",
      "1",
      "-1"
    ],
    "answer_index": 3,
    "explanation": "La función `foo` evalúa la función lambda `x` para los argumentos `y=2` y `z=1`. Esto resulta en $(2 \pmod 2) - (1 \pmod 2)$, que es $0 - 1 = -1$."
  },
  {
    "id": 35,
    "question": "¿Cuáles de las siguientes afirmaciones son verdaderas?\n\n(Selecciona dos respuestas.)",
    "options": [
      "Si el segundo argumento de open() es 'w' y la invocación tiene éxito, el contenido previo del archivo se pierde.",
      "Si el segundo argumento de open() es 'r', el archivo debe existir o open() fallará.",
      "El cierre de un archivo abierto se realiza mediante la función close().",
      "El segundo argumento de open() describe el método de apertura y por defecto es 'w'."
    ],
    "answer_index": [
      0,
      1
    ],
    "explanation": "El modo `'w'` (escritura) trunca el archivo existente si la apertura es exitosa, eliminando el contenido previo. El modo `'r'` (lectura) requiere que el archivo exista; de lo contrario, la función `open()` fallará."
  },
  {
    "id": 36,
    "question": "¿Cuál es el comportamiento esperado del siguiente código?\n\nmy_list = [i for i in range(5, 0, -1)]\nn = [my_list[i] for i in range(5) if my_list[i] % 2 == 0]\nprint(n)",
    "options": [
      "Produce como salida .",
      "Produce como salida .",
      "Produce como salida .",
      "El código es erróneo y no se ejecutará."
    ],
    "answer_index": 1,
    "explanation": "`my_list` es ``. La segunda lista por comprensión itera sobre esta lista y selecciona solo los números pares, en el orden en que aparecen (4, 2). La salida es ``."
  },
  {
    "id": 37,
    "question": "¿Cuál es la salida esperada del siguiente código?\n\nmy_l1 = range(-2, 2)\nm = list(filter(lambda x: True if abs(x) < 1 else False, my_l1))\nprint(len(m))",
    "options": [
      "Se genera una excepción",
      "16",
      "1",
      "4"
    ],
    "answer_index": 2,
    "explanation": "`my_l1` contiene `[-2, -1, 0, 1]`. La condición de filtro `abs(x) < 1` solo se cumple para $x=0$. Por lo tanto, `m` es ``, y su longitud es 1."
  },
  {
    "id": 38,
    "question": "¿Cuáles de las siguientes definiciones de lambda son correctas?\n\n(Selecciona dos respuestas.)",
    "options": [
      "lambda(x, y): x // y - x % y",
      "lambda x, y: x // y - x % y",
      "lambda x, y: (x, y)",
      "lambda x, y: return x // y - x % y"
    ],
    "answer_index": [
      1,
      2
    ],
    "explanation": "Las funciones lambda definen argumentos sin usar paréntesis `()` alrededor de ellos (descartando índice 0). Una lambda debe ser una única expresión (descartando índice 3 por usar `return`). Las opciones 1 y 2 cumplen con la sintaxis de argumento y expresión única."
  },
  {
    "id": 40,
    "question": "¿Cuál es la salida esperada del siguiente código si no existe un archivo llamado `non_existing_file` dentro del directorio de trabajo?\n\ntry:\n    f = open('non_existing_file', 'r')\n    print(1, end=' ')\nexcept IOError as error:\n    print(error.errno, end=' ')\n    print(2, end=' ')\nelse:\n    f.close()\n    print(3, end=' ')",
    "options": [
      "2 2",
      "1 2 2",
      "1 3",
      "2 2 3"
    ],
    "answer_index": 0,
    "explanation": "La función `open()` falla debido a que el archivo no existe en modo `'r'`, generando una `IOError`. La ejecución salta al bloque `except`, que imprime el número de error (`error.errno`, típicamente 2) seguido de 2. El bloque `else` se omite. La salida es `2 2`."
  }
]